            print('Using experimental pore data')
            factor = 10
            px = pore_data.attrs['voxel'].data
            radi = self.radi = px*np.sqrt(pore_data['value_properties'].sel(property = 'median_area').data/np.pi)
            heights = self.heights = px*pore_data['value_properties'].sel(property = 'major_axis').data
            size = self.labels.max() + 1
            #if size < len(radi):
             #   print('not all pores are connected, cleaning up heights and radii')
             #   radi = self.radi = px*np.sqrt(pore_data['value_properties'].sel(property = 'median_area', label = list(self.label_dict.keys())).data/np.pi)/factor
              #  heights = self.heights = px*pore_data['value_properties'].sel(property = 'major_axis', label = list(self.label_dict.keys())).data*factor**2/2   
            #if len(radi) < size: #it would be nice to have this as an input option, e.g. we use the experimental graph, but the properties are random
            #    print('Initializing pore props from ECDF distribution')
   
            ecdf_radi, ecdf_heights = ECDF(radi), ECDF(heights)
            #self.radi = interp1d(ecdf_radi.y[1:], ecdf_radi.x[1:], fill_value = 'extrapolate')(np.random.rand(size))/factor
            #self.heights = interp1d(ecdf_heights.y[1:], ecdf_heights.x[1:], fill_value = 'extrapolate')(np.random.rand(size))*factor**2
            self.radi = interp1d(ecdf_radi.y[1:], ecdf_radi.x[1:], fill_value = 'extrapolate')(0.5*np.ones(size))/factor
            self.heights = interp1d(ecdf_heights.y[1:], ecdf_heights.x[1:], fill_value = 'extrapolate')(0.5*np.ones(size))*factor**2
            
            #mean_height = interp1d(ecdf_heights.y[1:], ecdf_heights.x[1:], fill_value = 'extrapolate')(0.5)*factor**2/2
            #mean_radius = interp1d(ecdf_radi.y[1:], ecdf_radi.x[1:], fill_value = 'extrapolate')(0.5)/factor
            
           # self.heights = np.random_rng().normal(mean_height, 0.01*mean_height, size)
            #self.radi = np.random_rng().normal(mean_radius, 0.01*mean_radius, size)
            
            #ph = [5.7141757  1.22748472]
            #pr = [4.26008871, 1.22861912]
            
            #self.heights = px*np.random_rng().lognormal(ph[0], ph[1], size)*factor**2
            #self.radi = px*np.sqrt(np.random_rng().lognormal(pr[0], pr[1], size)/np.pi)/factor